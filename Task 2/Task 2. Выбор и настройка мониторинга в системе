Мониторинг.


1. Мотивация

В настоящее время компания «Александрит» собирает данные только через Яндекс Метрику, но этого недостаточно. С открытием API для партнёров у нас сильно выросло количество заказов, а также возросла вероятность проблем в интеграциях, связанных с RabbitMQ, CRM и MES. Наблюдаемость позволяет ответить на следующие вопросы:

    Почему возникают проблемы с заказами?
    Есть ли узкие места?
    Как быстро наши сервисы реагируют на запросы?
    
Мониторинг позволит:

    Повысить качество обслуживания, соблюдая SLA: своевременно выявлять узкие места и масштабировать компоненты.
	Сократить время на поиск и диагностику ошибок. 
    Находить и решать проблемы с узкими местами.
    Собирать бизнес-метрики (количество завершённых заказов, общая выручка) и принимать управленческие решения.
    

Для бизнеса это означает снижение затрат на аварийную работу над инцидентами, уменьшение количества жалоб клиентов и, как следствие, рост прибыли и лояльности. 
Мониторинг — это не только про рабтоспособность платформы, но ещё инструмент для анализа бизнеса на основе метрик.

2. Выбор подхода к мониторингу

Система «Александрит» состоит из нескольких ключевых компонентов: интернет-магазина (Shop API), CRM, MES и брокера сообщений (RabbitMQ). У каждого компонента своя специфика и метрики.

Будем использовать «четыре золотых сигнала» (latency, traffic, errors, saturation) для наших HTTP-сервисов (Shop, CRM, MES):

    Latency: время ответа API
    Traffic: количество запросов в секунду (RPS)
    Errors: коды ошибок (5xx, 4xx)
    Saturation: загрузка CPU, памяти, а также заполненность очередей

Для RabbitMQ и баз данных дополнительно можно применить некоторые приёмы из подхода USE (Utilization, Saturation, Errors):

    Utilization: сколько ресурсов используется (CPU, RAM, диски, соединения)
    Saturation: насколько очереди загружены
    Errors: сбои, переполненные очереди, dead-letter-сообщения

Таким образом, мы комбинируем «четыре золотых сигнала» для сервисов и «USE» для более низкоуровневых ресурсов (БД, очередь).

3. Метрики для отслеживания

Ниже описаны основные метрики, которые планируем отслеживать:

3.1 RabbitMQ

    Number of dead-letter-exchange letters
        Зачем: показывает, сколько сообщений отбрасывается из основной очереди. Рост этого показателя может указывать на ошибки в потребителях (MES, CRM) или неправильную маршрутизацию.
        Ярлыки: имя очереди, сервис-отправитель.
    Number of messages in flight
        Зачем: показывает, сколько сообщений в очереди обрабатывается в данный момент. Если это число стабильно высокое, значит потребители не справляются с нагрузкой.
        Ярлыки: имя очереди, тип сообщения.

3.2 API-сервисы (Shop, CRM, MES)

    Number of requests (RPS)
        Зачем: измерение «Traffic» из «четырёх сигналов». Позволяет понять общую загрузку сервиса.
        Ярлыки: метод запроса (GET, POST и т.д.), код статуса (200, 404, 500).
    Response time (latency)
        Зачем: ключевой показатель для SLA и удобства пользователей. Если время ответа растёт, нужна оптимизация.
        Ярлыки: URL-эндпоинт (по группам), код статуса.
    Number of HTTP 500
        Зачем: показывает количество критических ошибок на бэкенде. Рост – признак серьёзных проблем в работе Web-сервиса.
        Ярлыки: имя сервиса (Shop, CRM, MES), эндпоинт.
    CPU % (для Shop, CRM, MES)
        Зачем: при загрузке CPU выше порога (80%) сервис может не успевать обрабатывать запросы.
        Ярлыки: имя сервиса, окружение (dev/release/prod), регион.
    Memory Utilization (для Shop, CRM, MES)
        Зачем: при нехватке памяти может происходить OOM killer, сбои.
        Ярлыки: имя сервиса, окружение (dev/release/prod).

3.3 Базы данных (Shop DB, MES DB)

    Number of connections
        Зачем: важно понимать, не исчерпываем ли мы пул соединений. Если соединений слишком много, возможно утечки.
        Ярлыки: имя базы, хост.
    Memory Utilisation
        Зачем: при перегрузке памяти в БД запросы становятся медленнее, может произойти деградация.
        Ярлыки: окружение (dev/release/prod).
    Size of DB instance
        Зачем: контроль за ростом объёма базы, особенно если используется один инстанс.
        Ярлыки: название схемы (Shop, MES).

3.4 Хранилище (S3)

    Size of S3 storage
        Зачем: контролировать, насколько быстро растёт объём загружаемых 3D-моделей.
        Ярлыки: окружение (dev/release/prod).

При необходимости можно добавить метрики «Number of simultanious sessions», «Kb transferred» и т.д., но вышеуказанные — основные для быстрого старта.
4. План действий

    Выбор инструмента мониторинга и развёртывание time-series базы
        Prometheus + Grafana
    Настройка агентов и экспортеров
        Для сервисов на Java, C# и Vue: использовать готовые библиотеки (Micrometer, OpenTelemetry) для метрик.
        Для RabbitMQ: настроить RabbitMQ Exporter.
        Для баз данных: использовать PostgreSQL/MySQL exporter (в зависимости от используемой СУБД).
    Конфигурация дашбордов и алертинга
        Создать для дежурной смены мониторинга дашборды в Grafana, отразить ключевые метрики (RPS, ошибки, latency, CPU, память, очередь).
        Настроить оповещения (e-mail, Telegram) при превышении пороговых значений.
    Проверка и тестирование
        Провести нагрузочное тестирование (например, JMeter, Locust), чтобы убедиться, что метрики собираются корректно и алерты срабатывают.

5. Показатели насыщенности (thresholds)
5.1 Принципы выбора пороговых значений

    Используем общепринятые best-practices (80% для CPU/Memory).
    Для времени ответа — учитываем SLA (например, < 500 мс для внутренних сервисов, < 1 с для публичных).
    Для очередей — порог в зависимости от пропускной способности: например, если в очереди RabbitMQ более 100 сообщений, это может означать проблемы.

5.2 Действия при превышении порога

    CPU / Memory: при достижении 80% генерируется предупреждение. Если загруженность не спадает, автоматически создаётся тикет на масштабирование.
    Response time: если среднее время ответа API превышает X мс в течение определённого интервала, система отправляет алерт в мессенджер и на e-mail ответственных.
    Dead-letter messages: если количество dead-letter-сообщений резко растёт, то создается инцидент.
    Queue length: если очередь переполнена (свыше заданного порога), возможно auto-scaling потребителей (workers).

